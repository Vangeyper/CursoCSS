* {
    color: red; /* mejor en hexadecimal para ser exactos */
}

[rancio="sii"] {
    color:blue;
}

h2 p {
    color: green;
}

.titulo-h2 p {
    color: coral;
}

.titulo-h2 p span {
    color: blueviolet;
}

#miH2 b:hover {
    color:aqua;
}


.contact-form {
    color: black;
}

.contact-form__input {
    color: yellow;
}

.contact-form__input:first-child {
    color: red;
}

/*
SELECTORES

    Universal: * 
    De Tipo: cualquier sección html
        ej. h1, h2, input
    Clases: .nombreClase
    Identificador: #nombreIdentificador   tiene mas rango de especificidad que la clase => prioridad
    Atributo: [atributo="valor"]
    Descencientes: padre hijo 
        ej. h2 p {...}
        ej. .clase input {...}
        ej. #identificador label {...}
    pseudo-clases: por ejemplo los eventos de una clase
        ej: .clase:hover   siendo hover la pseudoclase


ESPECIFICIDAD

    Conflictos entre estilos aplicados al mismo objeto

    Siempre tiene persistencia el último estilo aplicado, el resto se aplica pero es sobreescrito, de ahí el nombre estilos en cascada, pero solo para elementos de la misma jerarquía,
    para elementos de la misma jerarquía, cuando son diferentes jerarquías se sigue la prioridad:
    
        !important   (indicamos a continuación del estilo, no es recomendable usarlo, caso extremo)
        Estilos en línea    (cuando indicamos dentro del html con style="" el estilo)
        Identificadores
        Clases, pseudo-clases y atributos
        elementos
        pseudo-elementos


METODOLOGIA BEM

    Nos basamos en el nombre de la clase para saber que elemento estamos seleccionando.

    A cada elemento si le aplicamos clase la ponemos con la nomenclatura::after
        class="nombreClaseContenedorOPadre__nombreClaseElemento"

    Ej. <div class="form">
            <input type="text" class="form__input">
            <input type="password" class="form__input">
        </div>
    
    Para los hijos de los hijos ya no se pone __  sino un simple -

    Ej. <div class="form">
            <input type="text" class="form__input">
            <input type="password" class="form__input">
            <p class="form__p"><h2 class="form__p-h2"></h2></p>
        </div>

        .form__p-h2 {
            color: red;            
        }


    Para cambiar al primero de los hijos input del contenedor contact-form::after
 
        .contact-form__input:first-child {
            color: red;            
        }
    
    Uso de --
    Otra forma es tener uno marcado con --marca:

    Ej. <div class="form">
            <input type="text" class="form__input">
            <input type="password" class="form__input--active">
        </div>
    
        .contact-form__input--active {
            color: red;            
        }        


TEORIA DE LAS MEDIDAS (relativas o fijas)
     
        Entre las medidas fijas tenemos:  
            pixeles 5px
            centimetros 5cm
            milimetros 5mm
            puntos 5pt

        Entre las medidas relativas tenemos:
            rem: tiene como referencia el root  
            em:  por defecto equivale a 16px aunque depende del navegador
                 La gracia del em es que su valor se hereda del contenedor, si en el contenedor tenemos un font-size de 20px cuando a un elemento hijo le aplicamos 
                 medidas em tendrá dicho valor como valor por defecto. Esto se aplica a todo lo que requiera medidas: font-size, padding, ...
            vw:  viewport width -> equivale al ancho de pantalla, se le indica un % de la misma. Ej. width: 100vw;   indica toda la pantalla
                 50vw sería el 50% de la pantalla
            vh:  viewport height -> equivale al alto de pantalla, se le indica un % de la misma. Ej. height: 100vh;   indica toda la pantalla
                 50vh sería el 50% de la pantalla
            %:   Indica un porcentaje de la caja que la contiene.



PROPIEDADES DE TEXTOS

    font-size: tamaño de la fuente aplicada
    font-family: familia de la fuente utilizada
    line-height: es el espacio ocupado por 1 letra. La particularidad es que nace del centro de la letra, si aplicamos line-height: 2; crecería media letra por encima 
                 y por debajo de la letra, es decir que al partir del centro crece por ambas partes por igual. No amplia la letra, sino que lo que amplia es el espacio ocupado, en el fondo 
                 haría como los margin - padding 
    font-weight: especifica el grosor aplicado a la fuente, si lo permite



NORMALIZE.css

    Se puede descargar y utilizar para recuperar los valores por defecto de estilos que deberían tener los navegadores:
        <link rel="stylesheet" type="text/css" href="normalize.css">
     
    Añadimos en las imágenes una línea para que las misma ocupen todo el ancho, esto es importante para los móviles:  max-width: 100%;

    img {
        border-style: none;
        max-width: 100%;
    }

    también añadimos para todos los elementos esto: 

    * {
        box-sizing: border-box;
        padding: 0;      con los 0 no hace falta indicar la unidad, porque se multiplica por cero
        margin: 0;
    }

    mantiene siempre la caja contenedora con las medidas establecidas aunque los elementos interiores quieran hacerla crecer.



TEORIA DE CAJAS

    Hay 2 tipos:

        las que son en linea:
            El ancho será el necesario para tener el contenido que le pongamos
            No se puede aplicar height o width, siempre ocupa lo que necesita
        las que son en bloque:
            Son las más grandes
            Se ajustan al ancho de la contenedora

    Para cambiar la disposición de uno a otro tenemos la propiedad display: inline;   display: block;

    


PROPIEDADES DE CAJAS

    background-color
    display: inline-block   --> permite que se comporte como un elemento en línea pero podrá adoptar las propiedades de un bloque.
        PADDING es la distancia entre los textos y los bordes de la caja contenedora.
    padding: 20px;    --> es como darle padding a todo: top, right, bottom y left
    padding: 10px 20px --> le da 10px al top y al bottom, mientras que le da 20px al right y al left
    padding: 30px 40px 50px 20px;   --> damos todos los paddings siendo por orden: top 30px, right 40px bottom 50px y left 20px  --> sigue el movimiento de las agujas del rejoj
    padding-top: 20px;
    padding-left: 20px;
    padding-right: 20px;
    padding-bottom: 20px;
    height: 10px; 
    width: 10px;
    box-sizing: content-box;  --> si no ponemos esto los tamaños son la suma de las propiedades, por ejemplo en este caso el height sería de 10px + 20px del padding-top + 20px del padding-bottom
                              --> pero al ponerlo la caja mantiene su tamaño y no crece o disminuye.
        MARGIN es la distancia entre 2 cajas consecutivas, al igual que el padding tiene 4 lados y se puede poner de las mismas formas.                              
        Ojo se aplica en todos los lados de las cajas contenedoras, y en el medio habría doble distancia porque aplicaría el margin o padding de ambas cajas contenedoras. Por eso en el medio se reducen 
        los valores de padding y margin a la mitad:  left y right
        Si ponemos margin: auto; a una caja de tipo block y no está posicionado lo que hacemos es centrarla en pantalla.
        Este centrado solo vale para el eje horizontal, no pasa con el eje de las Y
    margin: 20px; 
    margin: 10px 20px --> le da 10px al top y al bottom, mientras que le da 20px al right y al left
    margin: 30px 40px 50px 20px;   --> damos todos los margins siendo por orden: top 30px, right 40px bottom 50px y left 20px  --> sigue el movimiento de las agujas del rejoj
    margin-top: 20px;
    margin-left: 20px;
    margin-right: 20px;
    margin-bottom: 20px;
    border-radius: 10px;   --> indica el redondeado de las esquinas de las cajas contenedoras
    border-radius: 50%;   --> redondea toda la caja creando una circunferencia
    border: 4px solid blue  --> se indica el grueso del borde, el estilo y el color
    
    box-shadow: 2px 4px 15px 1px color;   --> es para dar sombra a la caja, siendo por orden los datos: desplazamiento para el lado, desplazamiento para abajo, difuminado, relleno y color 
    text-shadow: 2px 4px 15px color;  --> es para dar sombra al texto, siendo por orden los datos: desplazamiento para el lado, desplazamiento para abajo, difuminado y color 
        En ambos sombreados si queremos darle más intensidad basta con copiarlo y repetirlo separado por comas
    box-shadow: 2px 4px 15px 1px color, 2px 4px 15px 1px color;
    text-shadow: 2px 4px 15px color, 2px 4px 15px color; 

    transform: rotate(90deg);  es una función que se le pasa los grados como parámetros. Puede ser negativo para el efecto contrario de rotación.


OUTLINE:
    Es como un border pero no afecta al DOM, realmente no está dentro del DOM como lo estaría border. Es como un resaltado que no afecta a las posiciones de 
    los elementos, ni siquiera a la caja que lo utiliza.
    Aunque tengamos el box-sizing en cualquiera de sus opciones no reducirá ni hará grande la caja afectada, solo la remarcará sin mover el resto de elementos.
    El Outline tiene en cuenta el Z-Index de los elementos a la hora de pintar, por lo que pueden quedar ocultos algunos de los lados del resaltado si las cajas colindantes son más cercanas a la superficie.


POSITION:
    Permite posicionar un elemento. Este elemento adquiere nuevas propiedades como: top, right, left, bottom, z-index, ...
    Opciones posibles:
        Static: valor por defecto. Significa que NO está posicionado.
        Relative: 
            El espacio reservado por el elemento originalmente se convervará aunque se traslade a otra ubicación, y el resto de elementos no ocuparán su lugar.
            El elemento adquiere las propiedades top, left, right y bottom que se corresponden en sus origenes con los de la caja.
            Importante: si indicamos top o left tendrán prioridad sobre la propiedad bottom y right, ignorando estas últimas.            
        Absolute:
            El espacio reservado para el elemento deja de estarlo y pasa a ser ocupado por el próximo elemento.
            Las coordenadas de posicionamiento serán referidas al contenedor o al viewport si no tiene. Ya no serán referidas al origen de la caja como en el relative.
            El viewport es todo lo que podemos ver en pantalla, si apretamos F11 lo vemos.
            El ancho de los elementos con position: absolute; aunque sea una caja de tipo block pasará a ajustarse al contenido, si la queremos más grande habrá que indicarlo con medidas.
            El elemento contenedor debe estar posicionado, no vale como static. Si es static entonces los elementos contenidos tomarán como referencia al viewport para posicionarse como absolute.
        Fixed:
            Es igual en todo que el absolute, pero además tiene la particularidad que no se mueve nunca de la zona de pantalla aunque se realice scroll en la pantalla.
        Sticky:


Z-INDEX: 
    Orden de los elementos visualmente en el eje Z. Dicho de otra manera el que tenga el valor z-index más alto estará más cercano a nuestra vista y se verá por delante del resto de elementos con menor z-index.
    Esta propiedad se adquiere cuando la caja está posicionada, en el caso de position: static no existe o no tiene efecto.
    Tener en cuenta que por el hecho de estar posicionados aparecerán antes que otros elementos los últimos en pintarse, por efecto del orden de flujo al pintarse.
    Por defecto si no está posicionada tiene valor 0.
    En ese caso se tiene en cuenta el orden en que se pinta.
    Para poder agregar elementos nuevos y ordenarlos visualmente se recomienda poner incrementos de 50 o 100 en cada nuevo elemento z-index, asi podemos añadir elementos nuevos en medio.
    En el caso de contenedores padres e hijos, para que un hijo sea superado por el padre visualmente tenemos que ponerle un z-index: -1; al hijo y tener a ambos posicionados. En el padre no podemos tener ningún z-index definido para que funcione.


NOTA DE HTML

    Si pones 2 elementos en líneas diferentes automaticamente aunque el margin sea 0 deja un espacio entre las cajas contenedoras, 

        ej.
            <h2>Primera Caja</h2>
            <h2>Segunda Caja</h2>

    En cambio si las ponemos en la misma línea no dejará espacio::after

        ej.
            <h2>Primera Caja</h2><h2>Segunda Caja</h2>

    Opacity: indica la transparencia de un elemento, siendo 1 totalmente opaco y 0 totalmente transparente.
        ej.
            opacity: .5;  la mitad de transparencia

*/

.contact-form {
    font-size: 16px;
}

.contact-form__h2 {
    font-size: 2em;
    line-height: sans-serif, Georgia;  /* al separar por comas se coge la primera que exista por la izquierda */
    font-weight: 1000;  
}

.cajaConOutline, .cajaSinOutline {
    width: 200px;
    height: 200px;
    background: red;
    margin: auto;    
    box-sizing: content-box; /* las medidas indicadas a la caja se cumplirán para el interior de la misma y a eso habrá que añadir lo que ocupe el borde por ambos lados */
}

.cajaSinOutline {
    border: 10px solid blue;    
}

.cajaConOutline {
    background: yellow;
    outline: 10px solid blue; /* no ocupa espacio en pantalla */    
}

div {
    width: 120px;
    height: 120px;
    display: block;
}

.caja1 {
    background: orange;    
}

.caja2 {
    background: green; 
    position: relative;   
    top: 50px;
    left: 50px;
    z-index: 1;
}

.caja3 {
    background: lightblue;  
    position: relative;
}

.caja4 {
    background: yellow;   
}


.contenedor {
    width: 300px;
    height: 300px;
    background: blue;
    margin: 40px;
    position: relative;
}

.hijo {
    width: 120px;
    height: 120px;
    background: orange;
    position: relative;
    top: -20px;    
    left: -20px;
    z-index: -1; /* única forma de posicionar al padre por delante del hijo */
}


div {
    display: block;
    background: green;
    position: absolute;
}

div div {
    height: 75px;
    width: 75px;
    background: yellow;
}

.contenedor2 {
    width: 450px;
    height: 450px;
    border: 4px solid red;
    margin: 50px auto;
    position: relative; /* si este elemento contenedor no lo posicionamos y lo dejamos como static el resto de cajas no lo cojeran como referencia sino que pillarán el viewport */
}

.caja11 {
    background: orange;
    position: absolute;    
}

.caja12 {
    background: greenyellow; 
    position: absolute;    
    right: 0;
    top:0;
}

.caja13 {
    background: lightblue;
    position: absolute;  
    bottom: 0;  
    left: 0;
}

.caja14 {
    background: burlywood; 
    position: absolute;  
    bottom: 0;
    right: 0;
}

.caja15 {
    /* procedemos a centrar esta caja en su contenedor */
    top: 0;
    left: 0;
    bottom: 0;
    right: 0;
    margin: auto;
}